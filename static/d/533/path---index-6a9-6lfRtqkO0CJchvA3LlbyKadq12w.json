{"pageContext":{"group":[{"node":{"frontmatter":{"title":"휴지통 커스텀 아이콘 변경 후 자동으로 새로고침이 안될 때","date":"25 December, 2018","category":"etc"},"fields":{"slug":"/etc/181225/","categorySlug":"/categories/etc/"},"excerpt":"휴지통 모양을 변경하였는데, 휴지통이 비어었는 지 차있는 지가 제대로 아이콘에 적용되지 않는다. 레지스터 편집기를 열고, 다음의 경로로 이동. 기본값, empty, full 값에 대해 모두 아이콘확장자 뒤에   ,0  을 붙여준다."}},{"node":{"frontmatter":{"title":"Heapsort and Radixsort","date":"10 December, 2018","category":"알고리즘"},"fields":{"slug":"/study/algorithm/heapsort/2018-12-10/","categorySlug":"/categories/알고리즘/"},"excerpt":"Complete Binary Tree bottom level을 제외하면 왼쪽 차일드와 오른쪽 차일드가 전부 차있는 트리. Binary Heap Heap property를 갖고 있는 complete binary tree이다. max-heap…"}},{"node":{"frontmatter":{"title":"Backtracking","date":"09 December, 2018","category":"알고리즘"},"fields":{"slug":"/study/algorithm/backtracking/2018-12-09/","categorySlug":"/categories/알고리즘/"},"excerpt":"미로 찾기의 경우처럼, 지금 상태에서 앞으로 계속 진행한다고 하더라도 해답을 구할 수 없는 경우에는 앞으로 나아가는 것을 포기하고 이전 상태로 되돌아가서 다른 경우를 찾아본다. N-Queen Problem 4개의 queen…"}},{"node":{"frontmatter":{"title":"Graph Alogrithms","date":"09 December, 2018","category":"알고리즘"},"fields":{"slug":"/study/algorithm/graph/2018-12-09graph/","categorySlug":"/categories/알고리즘/"},"excerpt":"그래프 알고리즘 . 그래프의 표현 그래프는  Adjacency matrix(인접행렬)  이나  Adjacency list(인접 리스트) 로 나타낼 수 있다. 인접 행렬 은 connectivity…"}},{"node":{"frontmatter":{"title":"String Matching","date":"09 December, 2018","category":"알고리즘"},"fields":{"slug":"/study/algorithm/stringMatching/2018-12-09/","categorySlug":"/categories/알고리즘/"},"excerpt":"Substring search N의 길이의 text에서 M 길이의 패턴을 찾아라. Brute - Force Substring Search Naive Algorithm 각각의 text 위치에 대해 패턴과 같은지 찾기. 최악의 경우 (text…"}},{"node":{"frontmatter":{"title":"Greedy Approach (욕심쟁이 기법)","date":"08 December, 2018","category":"알고리즘"},"fields":{"slug":"/study/algorithm/greedyApproach/18-12-08greedy/","categorySlug":"/categories/알고리즘/"},"excerpt":"욕심쟁이 기법 . 입력으로 여러 개의 원소들의 집합 S가 주어진다. 해답으로는 문제에서 주어지는 조건을 만족하는 집합 S에 속하는 원소들의 부분집합 G…"}},{"node":{"frontmatter":{"title":"Dynamic Programming (1)","date":"07 December, 2018","category":"알고리즘"},"fields":{"slug":"/study/algorithm/dynamicProgramming/2018-12-07dp/","categorySlug":"/categories/알고리즘/"},"excerpt":"동적계획법 . Divide - and - Conquer  과 유사. 문제를 여러 개의 subproblem으로 나누고, 각각의 subproblem을 해결한 후, 원래 문제의 해답을 계산함. 그러나 각각의 subproblem…"}},{"node":{"frontmatter":{"title":"Dynamic Programming (2)","date":"07 December, 2018","category":"알고리즘"},"fields":{"slug":"/study/algorithm/dynamicProgramming/2018-12-07dp2/","categorySlug":"/categories/알고리즘/"},"excerpt":"2차 동적계획법 . 재귀식에서 2개의 변수가 필요한 문제 2차원 배열로 동적계획법 구현 ( 이항계수 문제, 동전교환 문제,  최장공통부분수열 문제 등…) 이항계수 계산문제 단계 1, 2) 이항계수의 구조분석 및 재귀식  단계…"}},{"node":{"frontmatter":{"title":"Longest Increasing Subsequence","date":"03 December, 2018","category":"알고리즘"},"fields":{"slug":"/study/algorithm/2018-12-03-LIS/","categorySlug":"/categories/알고리즘/"},"excerpt":"Longest Increasing Subsequence Subsequence란, 주어진 배열에서 몇개의 원소(element)를 선택한 부분배열입니다 (단, 하나의 substring…"}},{"node":{"frontmatter":{"title":"Serialize and Deserialize Binary Tree","date":"03 December, 2018","category":"자료구조"},"fields":{"slug":"/study/data_structure/tree/binarytree/","categorySlug":"/categories/자료구조/"},"excerpt":"링크:  https://leetcode.com/problems/serialize-and-deserialize-binary-tree/ 트리를 string 데이터 타입으로 serialize로 하고, seralized된 string…"}}],"pathPrefix":"","first":true,"last":false,"index":1,"pageCount":2,"additionalContext":{}}}