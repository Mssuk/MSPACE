{"data":{"site":{"siteMetadata":{"title":"MSPACE","author":"Song Min Suk"}},"markdownRemark":{"id":"94d5553e-d1bc-53b1-bd7e-23f9af66dd8d","excerpt":"동적계획법 Divide - and - Conquer  과 유사. 문제를 여러 개의 subproblem으로 나누고, 각각의 subproblem을 해결한후, 원래 문제의 해답을 계산함. 그러나 각각의 subproblem…","html":"<h2>동적계획법</h2>\n<p><strong>Divide - and - Conquer</strong> 과 유사.</p>\n<ul>\n<li>\n<p>문제를 여러 개의 subproblem으로 나누고, 각각의 subproblem을 해결한후, 원래 문제의 해답을 계산함.</p>\n</li>\n<li>\n<p>그러나 각각의 subproblem이 독립적이지 않을 때는 매우 많은 반복 연산이 이루어지게 됨.</p>\n</li>\n<li>\n<p>dynamic programming은 이 반복 연산을 제거한다.</p>\n</li>\n</ul>\n<ul>\n<li>\n<p><strong>Bottom-Up Approach</strong></p>\n<ul>\n<li>작은 문제부터 시작</li>\n<li>작은 문제를 해결한 후, 그 해답을 테이블에 저장.</li>\n<li>큰 문제를 해결하면서 작은 문제의 해답이 필요할 경우 테이블에 저장된 작은 문제의 해답을 이용.</li>\n</ul>\n</li>\n</ul>\n<p><em>최적화 문제 (Optimization Problem)</em></p>\n<ul>\n<li>\n<p>문제를 해결하는 해답이 여러 개 있지만, 그 중에서도 특정한 조건이 최대(혹은 최소)가 되는 해답을 구하는 문제.</p>\n<ul>\n<li>단계 1) 최적의 해답의 구조를 분석. (working backward 기법)</li>\n<li>단계 2) 최적의 해답의 최적값을 재귀식으로 정의(top-down)</li>\n<li>단계 3) 상향식(bottom-up)으로 최적값을 계산.</li>\n<li>이때 이미 계산한 작은 데이터에 대한 해답은 테이블에 저장 후, 필요한 경우에는 저장된 해답을 바로 사용한다.</li>\n<li>단계 4) 최적의 해답계산. 단계 3에서 발생하는 정보를 이용. reconsturct.</li>\n</ul>\n</li>\n</ul>\n<h4>1차 동적계획법</h4>\n<ul>\n<li>재귀식에서 1개의 변수가 필요. 1차원 배열로 동적계획법 구현.</li>\n</ul>\n<blockquote>\n<p> <strong>Fibnonacci 수 계산</strong></p>\n</blockquote>\n<p>simple recursive program</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> n<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>bottom-up ( Tabulated ) version</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> Fib<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    \n    Fib<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    Fib<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* base case */</span>\n    \n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        Fib<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Fib<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> Fib<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> F<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p><strong>동전 교환 문제</strong></p>\n</blockquote>\n<p>서로 다른 단위의 동전이 주어졌을 때, 거스름돈을 동전의 개수가 최소가 되도록 교환해 주려고 한다. 이 때 교환해 주는 동전의 최소 개수와 교환해 주는 동전의 조합을 계산하시오.  (단, 모든 단위의 동전은 무수히 많다.)</p>\n<ul>\n<li>\n<p>예</p>\n<ul>\n<li>동전의 종류: 1원, 5원, 10원, 21원, 25원</li>\n<li>거스름돈 63원</li>\n<li>최소 동전 개수 : 3개 , {21, 21, 21}</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p> 단계1)  <strong>Think Working Backward</strong></p>\n</blockquote>\n<ul>\n<li>동전조합의 구조 분석</li>\n</ul>\n<p>거스름돈 63원은, </p>\n<ol>\n<li>\n<p><strong>25원 + 38원</strong></p>\n</li>\n<li>\n<p><strong>21원+ 42원</strong></p>\n</li>\n<li>\n<p><strong>10원 + 53원</strong></p>\n</li>\n<li>\n<p><strong>5원 + 58원</strong></p>\n</li>\n<li>\n<p><strong>1원 + 62원</strong> 이다.</p>\n</li>\n</ol>\n<blockquote>\n<p> 단계2) 재귀식</p>\n</blockquote>\n<p>C(k) : k원을 바꿀 때, 최소 동전의 개수</p>\n<p>C(63) = min{C(38)+ 1, C(42)+1, C(53)+ 1, C(58)+ 1, C(62)+ 1}</p>\n<p>​\t = min{C(38), C(42), C(53), C(58), C(62) } + 1</p>\n<p>$$\nC(k) = min<em>1\\leq _i \\leq _nC(k-C</em>i)+1\n$$</p>\n<blockquote>\n<p> 단계3)  최소동전의 개수 계산 (Compute <strong>Bottom Up</strong>)</p>\n</blockquote>\n<p><img src=\"D:%5CCloneFloder%5Cblog%5Csrc%5Cpages%5Cstudy%5Calgorithm%5CdynamicProgramming%5Cmyimg1.PNG\"></p>\n<p>S[k] : 위의 C[k]를 계산할 때, 최솟값으로 선택된 동전을 저장.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">coinExchange</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> coins<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> numDiffCoins<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> change<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> coinSued<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> lastCoin<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    \n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"title":"Dynamic Programming","date":"December 07, 2018"}}},"pageContext":{"slug":"/study/algorithm/dynamicProgramming/2018-12-07dp/"}}