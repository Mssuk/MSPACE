{"data":{"site":{"siteMetadata":{"title":"MSPACE","author":"Song Min Suk"}},"markdownRemark":{"id":"94d5553e-d1bc-53b1-bd7e-23f9af66dd8d","excerpt":"동적계획법 Divide - and - Conquer  과 유사. 문제를 여러 개의 subproblem으로 나누고, 각각의 subproblem을 해결한후, 원래 문제의 해답을 계산함. 그러나 각각의 subproblem…","html":"<h2>동적계획법</h2>\n<p><strong>Divide - and - Conquer</strong> 과 유사.</p>\n<ul>\n<li>\n<p>문제를 여러 개의 subproblem으로 나누고, 각각의 subproblem을 해결한후, 원래 문제의 해답을 계산함.</p>\n</li>\n<li>\n<p>그러나 각각의 subproblem이 독립적이지 않을 때는 매우 많은 반복 연산이 이루어지게 됨.</p>\n</li>\n<li>\n<p>dynamic programming은 이 반복 연산을 제거한다.</p>\n</li>\n</ul>\n<ul>\n<li>\n<p><strong>Bottom-Up Approach</strong></p>\n<ul>\n<li>작은 문제부터 시작</li>\n<li>작은 문제를 해결한 후, 그 해답을 테이블에 저장.</li>\n<li>큰 문제를 해결하면서 작은 문제의 해답이 필요할 경우 테이블에 저장된 작은 문제의 해답을 이용.</li>\n</ul>\n</li>\n</ul>\n<p>최적화 문제 (Optimization Problem)</p>\n<ul>\n<li>\n<p>문제를 해결하는 해답이 여러 개 있지만, 그 중에서도 특정한 조건이 최대(혹은 최소)가 되는 해답을 구하는 문제.</p>\n<ul>\n<li>단계 1) 최적의 해답의 구조를 분석. (working backward 기법)</li>\n<li>단계 2) 최적의 해답의 최적값을 재귀식으로 정의(top-down)</li>\n<li>단계 3) 상향식(bottom-up)으로 최적값을 계산.</li>\n<li>이때 이미 계산한 작은 데이터에 대한 해답은 테이블에 저장 후, 필요한 경우에는 저장된 해답을 바로 사용한다.</li>\n<li>단계 4) 최적의 해답계산. 단계 3에서 발생하는 정보를 이용. reconsturct.</li>\n</ul>\n</li>\n</ul>\n<h4>1차 동적계획법</h4>\n<ul>\n<li>재귀식에서 1개의 변수가 필요. 1차원 배열로 동적계획법 구현.</li>\n</ul>\n<blockquote>\n<p> <strong>Fibnonacci 수 계산</strong></p>\n</blockquote>\n<p>simple recursive program</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> n<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>bottom-up ( Tabulated ) version</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> Fib<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    \n    Fib<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    Fib<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* base case */</span>\n    \n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        Fib<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Fib<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> Fib<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> F<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p><strong>동전 교환 문제</strong></p>\n</blockquote>\n<p>서로 다른 단위의 동전이 주어졌을 때, 거스름돈을 도전의 개수가 최소가 되도록 교환해 주려고 한다.</p>","frontmatter":{"title":"Dynamic Programming","date":"December 07, 2018"}}},"pageContext":{"slug":"/study/algorithm/dynamicProgramming/2018-12-07dp/"}}